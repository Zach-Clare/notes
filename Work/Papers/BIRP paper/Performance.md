The aim of this section is to discuss relative performance and how it changes with scale â€” not to discuss the absolute speed of computation. All performance results in this section were measured with an Intel(R) Core(TM) i7-1365U processor, a consumer-grade laptop CPU. During measurement, timings often fluctuated within 5ms and results will vary by much more than that on different hardware. 

The three renderings and associated timings shown in figure \ref{fig:resolution} show how computation time increases as the pixel degree width decreases. The smaller the width of each pixel, the more pixels that are required to cover the requested field of view. Therefore, in the context of a constant field of view, we can consider pixel width and resolution to have an inverse relationship. Figure \ref{fig:scaling} further visualises the positive exponential relationship between resolution and computation time. This is an expected trend because the image array is defined with $x{\times}y$. For example, adding a single $x$ column to the image requires $y$ more pixel rays.  

As shown in section \ref{imagegeneration}, each pixel is iterated on during rendering. For this reason, if we consider the resolution size as an input to the renderer, the software has a time complexity of O(n$^2$). Other inputs to the software do not meaningfully change the time complexity.